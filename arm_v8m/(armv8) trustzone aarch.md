
# 1. 概述

如果你是关心安全的开发者，我相信拿到armv8-m的架构肯定会问，armv8-m从芯片层级考虑安全的话，肯定首要是trustzone的技术，那么armv8-m的trustzone技术到底怎么考察安全性：

* 内存隔离
* 跳转安全state限制
* 预防SG指令的滥用（Inadvertent SG instruction in binary data）
* 虚假的函数和异常返回值的状态
* 预防在secure内存中的溢出问题
* 调试的权限管理设计

## 1.1 内存隔离

将内存分为安全内存和非安全内存是TrustZone的一项重要特性，其主要目的包括：

1. **隔离敏感数据：** TrustZone允许将敏感数据存储在安全内存中，而将非敏感数据存储在非安全内存中。这样，敏感数据在处理器的安全区域内受到保护，不容易被恶意软件或非授权的应用程序访问和泄露。
2. **执行安全代码：** 安全内存还用于存储安全性相关的代码，如加密和认证算法，以及安全启动代码。这些代码在非安全内存中不可见，从而提供了一种方式来执行和保护安全关键操作。
3. **隔离不受信任的应用：** 非安全内存用于存储不受信任的应用程序和操作系统组件。TrustZone通过硬件隔离确保这些应用程序和组件无法直接访问安全内存中的敏感数据或安全代码。
4. **防止侧信道攻击：** 通过将安全内存隔离，TrustZone有助于防止侧信道攻击，如缓存侧信道攻击和时序侧信道攻击，因为非安全的应用程序无法直接观察或干扰安全内存中的操作。
5. **提供硬件支持：** TrustZone利用ARM处理器的硬件支持，确保内存分区的强制执行。这是硬件级别的隔离，不容易被绕过。

## 1.2 跳转安全state限制

在ARM TrustZone环境中，SG指令和NSC内存属性的设计确保非安全态（Non-secure）到安全态（Secure）的分支（branch）只能在有效的入口点（valid entry points）上发生，从而限制和控制了跨越TrustZone边界的跳转。我们拆分这几个概念：

1. **SG指令（Secure Gateway Instruction）：** SG指令是用于在Non-secure态切换到Secure态的特殊指令。这个指令只能被受信任的代码和服务调用，并通常用于安全的上下文切换。SG指令的设计确保只有在受信任的入口点处才能执行此指令，防止非安全代码随意切换到安全态。
    
2. **NSC内存属性（Non-Secure Callable Memory Attribute）：** NSC内存是指在ARM TrustZone中用于存储非安全态代码和数据的内存区域。NSC内存属性是一种标记或属性，用于标识哪些内存区域包含非安全代码。这些内存区域只能包含在受信任的入口点处执行的代码。
    
3. **有效的入口点（Valid Entry Points）：** 有效的入口点指的是那些受信任的、经过验证和授权的位置，这些位置是允许进行从Non-secure到Secure态的切换的地方。这些入口点通常包括受信任的启动代码、安全服务或受信任的应用程序。
    

因此，SG指令和NSC内存属性的设计确保非安全态到安全态的分支只能在经过验证的、受信任的入口点上执行。这就限制了从非安全环境到安全环境的跳转，只有在确保受信任的方式下才能进行。这有助于确保TrustZone的安全隔离得到维护，防止不受信任的代码或操作绕过安全性控制。这是TrustZone的一项关键安全特性，有助于确保安全的上下文切换和安全的代码执行。


## 1.3 预防SG指令的滥用

上面介绍SG指令是用于在Non-secure态切换到Secure态的特殊指令，如果SG指令被滥用可能会造成安全问题。在二进制数据中（通常是在应用程序或固件的二进制代码中），可能会不经意地包含了SG（Secure Gateway）指令，这个不经意的行为导致，在TrustZone环境中从Non-Secure State（非安全态）切换到Secure State（安全态），并执行安全代码（视为严重的安全问题）。这意味着非受信任的代码或应用程序可能尝试执行这个指令，试图切换到Secure State，从而干扰或绕过TrustZone的安全隔离。

通常，不经意的SG指令可能是由于编译器错误、代码混淆问题或其他不当的操作而引入的。为了确保系统的安全性，需要定期审查二进制数据，以检测并纠正这类问题。此外，ARM TrustZone的设计要求在硬件和软件层面都要有正确的配置和实施，以确保不经意的SG指令不会引发安全风险。其中NSC内存属性就是一个重要的检测机制，在执行前会进行NSC内存属性检查，以确保在非安全区域调用了SG指令是真实有效的指令。

ARM TrustZone设计中，检测SG（Secure Gateway）指令没有被滥用是通过硬件和软件协同来实现的，以确保指令的正确用途和限制不被滥用。以下是一些方法和机制来检测SG指令没有被滥用：

1. **硬件级别的权限控制：** ARM TrustZone支持硬件级别的权限控制，其中访问Secure态的代码和资源必须经过硬件授权。这包括对SG指令的执行权限。硬件会验证是否允许执行SG指令，如果没有正确的权限，将不允许执行。
    
2. **受信任的入口点：** SG指令只能在受信任的入口点处执行。这些入口点通常由受信任的启动代码、安全服务或受信任的应用程序提供。硬件确保SG指令只在这些合法的入口点处执行，以防止滥用。
    
3. **硬件栈保护：** ARM TrustZone可以通过硬件栈保护措施来确保在切换到Secure态时保护堆栈的一致性和完整性，防止栈溢出等问题。

这些机制和方法结合起来确保了SG指令不会被滥用。通过硬件和软件的协同工作，ARM TrustZone提供了一个严格的安全框架，以保护敏感的安全操作和数据。这有助于防止非受信任的代码或操作绕过TrustZone的安全隔离。

当然ARM还做了一些其他的操作，例如，对于函数返回值及状态用一些虚假值来替换，一方面隐藏了非安全视角调用过程的追踪，一方面一定程度上还检测了SG指令的滥用。

## 1.4 伪造返回地址

"Faking of a return address when calling a Secure API" 意味着当在调用一个安全API（Application Programming Interface，应用程序编程接口）时，存在可能伪造返回地址的风险。这个问题涉及到在ARM TrustZone环境中的一个安全性问题，通常与栈溢出或函数调用相关。

1. **安全API调用：** 在ARM TrustZone环境中，安全API通常是由安全的代码提供的，用于执行敏感操作或提供受保护的服务。这些API允许非安全环境的代码（Non-Secure World）请求安全环境（Secure World）执行某些操作。
    
2. **返回地址：** 在函数调用中，返回地址是在函数调用之后控制流将返回的位置。与ARMv7m一致，ARMv8m中procedure call中返回地址， [02_ARMv7-M_编程模型与模式](https://github.com/carloscn/blog/issues/123) 存储在R14-link register(LR) 寄存器中。而ARMv8m考虑安全问题，**SG指令执行时的返回状态存储：** 当SG指令在执行时，它会将函数的返回状态存储在链接寄存器（Link Register，LR）的最低有效位（Least Significant Bit，LSB）中。这个返回状态通常是一个标志位，用于指示函数是从安全态还是非安全态被调用的。当函数返回时，**系统会检查LR中的最低有效位，以验证函数是否按照预期的状态返回**。这个检查是为了确保Secure API函数（通常是从Non-Secure环境调用的）不会返回到一个伪造的返回地址，该地址指向Secure环境中的代码。
    
3. **伪造返回地址：** "Faking of a return address" 意味着攻击者可能尝试伪造或篡改在调用安全API时存储在栈上的返回地址。这可能导致控制流在不受信任的位置上恢复执行，而不是按照正常的执行流程返回到调用者所期望的位置。ARMv8m通过在LR中存储返回状态，并在返回时检查它，系统可以确保Secure API函数不会被诱导返回到一个伪造的地址，该地址可能包含恶意代码或试图绕过TrustZone的安全隔离的代码。

这种设计也是有考虑的，例如x86架构把指令的返回地址要放在栈上，而不是单独弄个寄存器。

>x86/x64 cpu里确实有一个return stack buffer, 不过对汇编指令不可见，用来做跳转预测，长度有限（我看过一些架构的白皮书，好像通常是16个？），线程调用栈超过了长度就会导致预测失败（正常情况下，绝大部分预测都很准的）。intel/amd在很早的架构里就实现了这个优化的，arm也有类似的实现。
>intel最新的一轮漏洞和这个有关系 [Post-barrier Return Stack Buffer Predictions / CVE-2022-26373 /...](https://link.zhihu.com/?target=https%3A//www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/advisory-guidance/post-barrier-return-stack-buffer-predictions.html)

这样会把地址存储在这个问题的出现通常涉及到栈溢出攻击或其他安全漏洞，其中攻击者试图修改栈上的数据，包括返回地址，以便执行恶意代码或绕过TrustZone的安全隔离。

为了防止这种问题，ARM TrustZone的设计通常包括硬件和软件的措施：

- **硬件栈保护**：硬件可以实施栈保护机制，以确保栈上的数据不易被篡改，从而保护返回地址。
- **栈溢出检测**：软件可以实施栈溢出检测机制，以捕获和报告任何栈溢出事件。
- **权限控制**：只有具有适当权限的代码才能调用安全API，这有助于确保只有受信任的代码能够访问并修改返回地址。

## 1.5 使用FNC_RETURN机制获取地址从而控制代码执行路径

ARMv7架构没有FNC_RETURN机制，这部分是ARMv8-M新引入的机制。

"Attempting to switch to the Secure side using FNC_RETURN (function return code)" 意味着尝试使用FNC_RETURN（函数返回代码）来切换到安全环境的行为。这个问题涉及到ARM TrustZone中的一个安全性问题，其中FNC_RETURN通常用于函数返回并控制执行流。

1. **FNC_RETURN（函数返回代码）：** FNC_RETURN通常是一个用于在函数返回时设置返回状态的代码或值。它指示函数应该如何返回，并在返回后控制执行流。
    
2. **尝试切换到安全环境：** "Attempting to switch to the Secure side" 意味着在函数返回时，有尝试将执行流从非安全态（Non-Secure World）切换到安全态（Secure World）的行为。这通常是通过函数返回的方式来实现的，以控制执行流程。

```C
ret = non_secure_call_api(xxx); // FNC_RETURN 可以读取寄存器的值，如果正常ret返回的值是0那么进入非安全的一个分支（预期）。但是攻击者通过修改FNC_RETURN让函数进入do_secure_functions()的函数，那么处理器进入到安全状态，达到攻击者的要求。
if (ret == 0) {
	do_non_secure_function();
} else {
	do_secure_functions();
}
```

这个问题可能涉及到尝试滥用FNC_RETURN来实现非受信任代码或非受信任环境试图切换到安全环境的情况。这种行为可能导致绕过TrustZone的安全隔离，从而引发安全风险。为了防止这种问题，ARM TrustZone通常实施了硬件和软件的安全措施：

使用BLXNS指令来确保存在有效的返回堆栈，并防止恶意的非安全代码尝试使用FNC_RETURN机制切换处理器到安全代码，从而导致安全软件崩溃。**使用BLXNS指令：** 是为了在从不可返回的安全代码切换到非安全环境时确保安全性。这个指令用于**切换到非安全态，并确保存在有效的返回堆栈**。这个返回堆栈可以在需要时用于进入错误处理程序。相当于ARM多了一道检查。我们可以这么理解，从软件角度，我们只能使用`ret == xxx`的方式来检查返回值，但是C语言提取ret的之前，这部分是从LR中拿到的值，可能已经被攻击者修改了。而执行BLXNS指令时，**硬件会自动被LR给入栈到安全世界的MSP或者PSP堆栈中**，然后被FUC_RETURN赋值给LR，传递到非安全世界。那么这样，非安全世界，既看不到刚才安全世界执行时通用寄存器的值，也看不到从自己这里返回后，安全世界下面要执行的指令的地址，接着安全世界从MSP或PSP堆栈中继续执行。非安全世界里的代码执行完成后，返回安全世界，使用的跳转指令是普通的BX，目标地址是FNC_RETURN。硬件识别到这个动作后，会自动从安全世界的堆栈，把真正的LR赋值给到PC值，然后软件再从安全堆栈里恢复之前用到的通用寄存器值，继续往下执行。

从非安全世界，调用安全世界的代码，无需软件和硬件做太多事情，因为非安全世界，没有什么秘密的上下文，需要对安全世界隐瞒的。直接按照TZ架里要求的跳转到NSC，non-secure callabler区域，先执行一条SG指令，再执行其后的跳转指令，到S区域里函数实现的地方去执行就可以了。从非安全世界带来的LR，在安全世界仍然可见；并且在返回时，赋值给PC来做跳转回非安全世界[^1]。

## 1.6 假的异常EXC_RETURN

ARMv7架构原本就有EXC_RETURN这个机制，是异常返回后的地址信息。

"Faking of EXC_RETURN (exception return code) to return to Secure state illegally" 意味着尝试伪造EXC_RETURN（异常返回代码）以非法返回到安全状态。这个问题涉及到ARM TrustZone中的一个安全性问题，其中EXC_RETURN通常用于控制从异常处理程序返回到不同的执行状态。

1. **EXC_RETURN（异常返回代码）：** EXC_RETURN是一个特殊的值，通常在异常处理程序中使用，以指示异常处理程序应该如何返回到不同的执行状态。这个值包括信息，例如返回到异常处理程序的地址、控制模式和堆栈状态等。
    
2. **非法返回到安全状态：** "return to Secure state illegally" 意味着尝试从非安全状态返回到安全状态，而这个操作是未经授权的或非法的。在ARM TrustZone中，安全状态和非安全状态应该受到明确的控制和隔离，不应该随意切换或返回。
    
这个问题可能涉及到尝试滥用EXC_RETURN值以非法方式返回到安全状态的情况，而这可能导致绕过TrustZone的安全隔离，从而引发安全风险。

为了防止这种问题，ARM TrustZone通常实施了硬件和软件的安全措施：

1. **非安全中断的发生：** 当安全代码正在执行时，如果发生了一个非安全中断，处理器会自动将一个签名值（signature value）添加到当前的安全栈帧中。
    
2. **安全栈帧签名：** 这个签名值是一个安全栈帧的一部分，用于标识栈帧是否已被修改或干扰。签名值的生成通常基于栈帧的内容，包括返回地址和其他关键信息。
    
3. **异常返回时的签名检查：** 当非安全软件试图使用异常返回（exception return）指令来切换到安全环境时，处理器会执行签名检查。它将检查安全栈帧中的签名值是否与栈帧内容一致，以确保栈帧未被篡改。
    
4. **检测非法切换：** 如果签名检查失败，即签名值与栈帧内容不匹配，处理器将检测到非法切换尝试，因为非安全软件试图非法切换到安全环境。这将触发错误处理或其他相应的安全措施。
    
总之，这个机制通过在非安全中断期间添加签名值到安全栈帧，并在异常返回时执行签名检查，帮助检测非安全软件试图非法切换到安全环境的行为。这有助于维护ARM TrustZone的安全性，确保只有受信任的代码能够执行和返回到安全环境。

这部分可以参考：https://www.sciencedirect.com/topics/engineering/secure-stack

## 1.7 堆栈溢出

"Attempt to create stack overflow in Secure software" 意味着尝试在安全软件中创建堆栈溢出。堆栈溢出是一种常见的安全漏洞，通常涉及到在程序的执行期间，将过多的数据写入堆栈（stack）中，导致溢出并可能覆盖了堆栈中存储的关键数据或控制信息。

在ARM TrustZone或任何其他安全架构中，安全软件的堆栈安全性至关重要。堆栈溢出可能导致以下问题：

1. **破坏程序的完整性：** 堆栈溢出可以导致程序的崩溃或异常终止，从而破坏了程序的完整性。
2. **潜在的安全风险：** 如果堆栈溢出覆盖了存储在堆栈上的关键数据，可能会导致潜在的安全风险，如信息泄露、远程代码执行或拒绝服务攻击。
3. **绕过安全隔离：** 在安全架构中，堆栈溢出可能被攻击者用来绕过安全隔离，使得恶意代码能够进入安全环境。

关于ARMv8-M主流和基线子配置中的Secure堆栈指针的堆栈限制特性，以及对于堆栈溢出的处理。

具体来说：

1. **Secure堆栈指针的堆栈限制：** 在ARMv8-M主流和基线子配置中，实施了针对Secure堆栈指针的堆栈限制特性。这意味着系统可以检测和处理Secure堆栈的溢出情况。当Secure堆栈达到其限制时，会引发堆栈溢出异常。
    
2. **异常处理程序：** 当堆栈溢出异常发生时，异常处理程序会被触发，以确保适当的处理。这可能包括记录异常、中断执行流程并采取必要的纠正措施，以维护系统的安全性。
    
3. **调试方面的安全性：** 这段描述还提到了在调试方面处理安全性要求。这可能包括确保调试工具和过程不会威胁系统的安全性，或者确保调试过程受到适当的安全控制和监控。


*  [^1]:[从Cortex-M33内核认识TrustZone](https://www.stmcu.com.cn/ecosystem/chip/chipfamily-STM32L5)