# Linux System : Managing Linux Services - initramfs 

The NXP-IMX6ULL is the NXP cortex-A7 (Armv7 arch) and the Xilinx ZYNQ is the cortex-A53 (Armv8 arch). We will use the cortex-A7 and cortex-A53 as initramfs examples to decribe how to setup the initramfs before booting the real rootfs. The article will introduce as follows:

* What is the initramfs?
* Build initramfs
* Custom initramfs
* Populate initramfs into kernel or uboot

# 1. What is the initramfs

## 1.1 initramfs/initrd introducation

The initramfs is the solution introduced for the 2.6 Linux kernel series. The idea is that there's a lot of initialization magic done in the kernel that could be just as easily done in userspace.[^1]

Initial RAM disk (INITRD) provides the capability to load a RAM disk by the boot loader during the Linux startup process. The Linux kernel mounts it as RootFS and starts the initialization process. This section describes the procedure to configure the INITRD boot[^3].

Initial RAM file system (INITRAMFS) is the successor of INITRD. It is a `cpio` archive of the initial file system that gets loaded into memory during the Linux startup process. The Linux kernel mounts it as RootFS and starts the initialization process[^2].

At a first glance, it is only slightly different than a traditional initrd. Initramfs' are loaded quite a bit sooner than initrd's are. The key parts of initramfs are[^1]:
-   CPIO archive, so no filesystems at all are needed in kernel. The archive is simply unpacked into a ram disk.
-   This unpacking happens before do_basic_setup is called. This means that firmware files are available before in-kernel drivers load.
-   The userspace init is called instead of prepare_namespace. All finding of the root device, and md setup happens in userspace.
-   An initramfs can be built into the kernel directly by adding it to the ELF archive under the section name .init.ramfs
-   initramfs' can be stacked. Providing an initramfs to the kernel using the traditional initrd mechanisms causes it to be unpacked along side the initramfs' that are built into the kernel.
-   All magic naming of the root device goes away. Integrating udev into the initramfs means that the exact same view of the /dev tree can be used throughout the boot sequence. This should solve the majority of the SATA failures that are seen where an install can succeed, but the initrd cannot boot.

There is an using the initramfs example which initramfs decrypts the encrypted rootfs before mounting real rootfs, you can refer to the link: [[Embedded] enabling the cryptsetup on ramdisk](https://github.com/carloscn/blog/issues/170).
In this article, we will introduce INITRAMFS rather than INITRD. 

## 1.2 initramfs principle

The Linux kernel interacts with a file system while it’s running.  The kernel supports a wide variety of memory storage devices where the filesystem can be stored.  Most storage devices are persistent, which means they remember their state when powered off.  The Linux kernel can also run in volatile memory, such as RAM.  Some reasons for doing this include speed, since volatile memory is usually much faster, and the ability to modify a persistent file system while it’s not in use.  The Linux kernel can be configured to run from RAM by using the initramfs feature[^5].

When using initramfs, a filesystem image is embedded into the kernel image.  When the kernel boots, it extracts the filesystem image into RAM and runs an init script from there.  The init script is usually a file called ‘init’ in the root of the ramfs filesystem, but this can be overridden by setting the ‘rdinit’ variable in the Linux command line from the boot loader.  Configuring the Linux kernel to use initramfs is done through the menuconfig system.  The option is “Initial RAM filesystem and RAM disk” in the General Setup section.  The configuration requires the filename of the filesystem image to embed in the kernel.  Creating the ramfs filesystem image must be done separately from building the kernel[^5].

<div align='center'> <img src="https://raw.githubusercontent.com/carloscn/images/main/typora20230115104733.png" width="80%" /> </div>

After the initramfs finished tasks, initramfs will switch to the real root file system by `switch_root`[^6].

# 2. Build initramfs

## 2.1 build source code

This post explains how to load a ramdisk on iMX boards. The `initrd` and `initramfs` are two ways for achieving this. This tutorial approaches only the `initrd` (initial ram disk) method. This guide uses iMX6Q Sabre SD Board, and uses a file system generated by [Buildroot](https://buildroot.org/).

Follow the next steps to enable the Kernel to support `initrd`:

```
$ make menuconfig
```

Then, mark the following packages in _General setup_:

-   Initial RAM filesystem and RAM disk (initramfs/initrd) support
-   Support initial ramdisk/ramfs compressed using gzip.

Compile the Kernel:

```
$ make
```

For building the `initrd` on Buildroot file system, follow the next steps:

```
$ git clone git clone git://git.buildroot.net/buildroot
$ cd buildroot/
$ make imx6-sabresd_defconfig
$ make menuconfig
```

Then, mark the following option:

-   File system > initial RAM filesystem linked into linux kernel

Compile the file system:

```
$ make
```

The result of this compilation is a _rootfs.ext2.gz_ file.

For converting the file system to the right format, it is required to use `mkimage` tool. To install the tool use the following command:

```
$ sudo apt-get install u-boot-tools
```

Run the following command:

```
$ cd output/images/
$ mkimage -A arm -O linux -T ramdisk -C gzip -n "Build Root File System" -d rootfs.ext2.gz rootfs.ext2.gz.uboot
```

## 2.2 get built ramdisk directly

The file  [arm_ramdisk.image.gz](https://xilinx-wiki.atlassian.net/wiki/download/attachments/18842473/arm_ramdisk.image.gz?version=1&modificationDate=1536675884034&cacheVersion=1&api=v2) of  https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18842473/Build+and+Modify+a+Rootfs.

For making the `uramdisk.gz` follows the next steps:

```
$ gunzip ramdisk.image.gz
$ sudo mount -o loop ramdisk.image tmp_mnt
$ cd tmp_mnt
```

Change the `/etc/inittab` file[^8]:
* Add /dev/ttymxc0
* Delete /dev/ttyPS0

```
$ cd ..
$ sudo umount tmp_mnt
$ gzip ramdisk.image
$ mkimage -A arm -T ramdisk -C gzip -d ramdisk.image.gz uramdisk.image.gz
```

# 3. Custom Script

Set the u-boot script that is booting from ramdisk.

```
setenv bootargs console=ttymxc0,115200 root=/dev/ram0 

mmc dev 0; fatload mmc 0:2 80800000 zImage; fatload mmc 0:2 83000000 device.dtb; fatload mmc 0:2 90000000 uramdisk.image.gz;

bootz 80800000 90000000 83000000
```


# Ref
[^1]:[Ubuntu Wiki - Initramfs](https://wiki.ubuntu.com/Initramfs)
[^2]:[Configuring INITRAMFS Boot](https://docs.xilinx.com/r/en-US/ug1144-petalinux-tools-reference-guide/Configuring-INITRAMFS-Boot)
[^3]:[Configuring INITRD Boot](https://docs.xilinx.com/r/en-US/ug1144-petalinux-tools-reference-guide/Configuring-INITRD-Boot)
[^4]:[Xilinx Wiki - Linux Xilinx Open Source - Linux - Build and Modify a Rootfs](https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18842473/Build+and+Modify+a+Rootfs)
[^5]:[How do I use Linux initramfs?](https://vocal.com/resources/development/how-do-i-use-linux-initramfs/)
[^6]:[switch_root busybox init problems?](https://stackoverflow.com/a/38349741/14574212)
[^7]:[How to boot imx using ramdisk](https://imxdev.gitlab.io/tutorial/How_to_boot_imx_using_ramdisk/)
[^8]:[arm移植ubuntu系统出现A start job is running for dev-ttymxc0.device](https://www.cirmall.com/bbs/thread-103174-1-1.html)
